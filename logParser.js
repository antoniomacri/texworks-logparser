// TeXworksScript
// Title: Errors, warnings, badboxes
// Description: Looks for errors, warnings or badboxes in the LaTeX terminal output
// Author: Jonathan Kew, Stefan Löffler, Antonio Macrì, Henrik Skov Midtiby
// Version: 0.7.4
// Date: 2012-03-18
// Script-Type: hook
// Hook: AfterTypeset

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


// String.trim() and String.trimLeft() were introduced in Qt 4.7
if(typeof(String.prototype.trim) == "undefined")
{
  String.prototype.trim = function() { return this.replace(/^[\s\n]+|[\s\n]+$/g, ""); };
}

if(typeof(String.prototype.trimLeft) == "undefined")
{
  String.prototype.trimLeft = function() { return this.replace(/^[\s\n]+/, ""); };
}

if(typeof(String.prototype.trimRight) == "undefined")
{
  String.prototype.trimRight = function() { return this.replace(/[\s\n]+$/, ""); };
}

// For performance issues, we define and use a StringBuilder
function StringBuilder()
{
  this.buffer = [];
}

StringBuilder.prototype.append = function(s)
{
  this.buffer.push(s);
  return this;
}

StringBuilder.prototype.toString = function()
{
  return this.buffer.join("");
}

// Enums
var Severity = { BadBox:0, Warning:1, Error:2 };
var SortBy = { Severity:0, Occurrence:1 };

// Constructor
function Result(s, f, r, d)
{
  this.Severity = s;
  this.File = f;
  this.Row = r;
  this.Description = d;
}

Result.Equals = function(a, b)
{
  return a.Severity == b.Severity && a.File == b.File &&
         a.Row == b.Row && a.Description == b.Description;
}

// Constructor
function LogParser()
{
  this.Patterns = [
    {
      // This pattern recognizes all errors generated with \errmessage,
      // that is, starting with "!" and containing "l.\d+".
      // The macro \GenericError uses \errmessage internally.
      // Macros \@latex@error and \(Class|Package)Error use \GenericError.
      Regex: new RegExp("^!\\s((?:.*\n)+?l\\.(\\d+)\\s(?:.*\\S.*\n)+)"),
      Callback: function(m, f) {
        return new Result(Severity.Error, f, m[2], m[1].trim());
      }
    },
    {
      // This pattern matches all warnings generated with \(Class|Package)(Warning|WarningNoLine).
      // Additionally, it recognizes other warnings like "LaTeX Font Warning: ...\n(Font) ...".
      // The macro \GenericWarning does not produce formatted output, so it is impossible
      // to match it. We need to look for output generated by higher level commands.
      Regex: new RegExp("^((?:Class|Package|LaTeX) ([^\\s]+) Warning: .+\n)(?:\\(\\2\\)\\s([^\n]+)\n)*(?!\\(\\2\\))"),
      Callback: function(m, f) {
        // We remove "\n(<name>) " from description:
        var desc = m[0].replace(new RegExp("\\(" + m[2] + "\\)\\s([^\n]+)\n", "g"), " $1 ").replace(/\s+/g, " ").trim();
        var row = /on input line (\d+)\./.exec(m[0]);
        return new Result(Severity.Warning, f, row ? row[1] : 0, desc);
      }
    },
    {
      // This pattern matches all warnings generated using \@latex@warning and  \@latex@warning@no@line
      // (which add a little formatting before resorting to \GenericWarning).
      // Warnings generated this way should use \MessageBreak, but sometimes they don't, so we read until we find
      // a dot followed by a newline.
      Regex: new RegExp("^LaTeX Warning: (?:(?!\\.\n).|\n)+\\.\n"),
      Callback: function(m, f) {
        m[0] = m[0].replace(/\n/g, "").trim();
        var row = /on input line (\d+)\./.exec(m[0]);
        return new Result(Severity.Warning, f, row ? row[1] : 0, m[0]);
      }
    },
    {
      // This pattern recognizes badboxes. Each message can span over multiple lines.
      // TODO: how to determine when it ends?
      Regex: new RegExp("^((?:Under|Over)full \\\\[hv]box\\s*\\([^)]+\\) in paragraph at lines (\\d+)--\\d+)\n.+"),
      Callback: function(m, f) {
        return new Result(Severity.BadBox, f, m[2], m[0].trim());
      }
    }
  ];

  this.Settings = {
    SortBy: SortBy.Occurrence,
    MinSeverity: Severity.BadBox
  };
}


LogParser.prototype.Parse = function(output, rootFileName)
{
  var skipRegexp = new RegExp("^[^\n\r()]+");
  var currentFile = undefined, fileStack = [], extraParens = 0;

  // Generate or clear old results
  this.Results = [];

  while (output.length > 0) {
    // Be sure to remove any whitespace at the beginning of the string
    output = output.trimLeft();

    // Text matched by some patterns (especially badboxes) may contain
    // unbalanced parenthesis: we'd better look for every pattern, to
    // gobble such text and avoid those parenthesis conflict with the
    // file stack.
    for (var i = 0; i < this.Patterns.length; ) {
      var match = this.Patterns[i].Regex.exec(output);
      if (match) {
        var result = this.Patterns[i].Callback(match, currentFile);
        if (result) {
          if (result.Severity >= this.Settings.MinSeverity) {
            // Here we filter desired results
            this.Results.push(result);
          }
          // Always trimLeft before looking for a pattern
          output = output.slice(match[0].length).trimLeft();
          i = 0;
        }
      }
      else {
        i++;
      }
    }

    // Go to the first parenthesis or simply skip the first line
    var match = skipRegexp.exec(output);
    if (match) {
      output = output.slice(match[0].length);
    }
    if (output.charAt(0) == ")") {
      if (extraParens > 0) {
        extraParens--;
      }
      else if (fileStack.length > 0) {
        currentFile = fileStack.pop();
      }
      output = output.slice(1);
    }
    else if (output.charAt(0) == "(") {
      var result = LogParser.MatchNewFile(output, rootFileName);
      if (result) {
        fileStack.push(currentFile);
        currentFile = result.File;
        output = result.Output;
        extraParens = 0;
      }
      else {
        extraParens++;
        output = output.slice(1);
      }
    }

    this.CheckForRerunOfLatex(output);
  }
  this.WarnAuxFiles();
}


LogParser.MatchNewFile = (function()
{
  // Should catch filenames of the following forms:
  //  * ./abc, "./abc"
  //  * /abc, "/abc"
  //  * .\abc, ".\abc"
  //  * C:\abc, "C:\abc"
  //  * \\server\abc, "\\server\abc"    <-- TODO: is it really needed?
  var fileRegexp = new RegExp('^\\("((?:\\./|/|\\.\\\\|[a-zA-Z]:\\\\)(?:[^"]|\n)+)"|^\\(((?:\\./|/|\\.\\\\|[a-zA-Z]:\\\\)[^()\n]+)');
  var fileContinuingRegexp = new RegExp('[/\\\\()\n]');
  var filenameRegexp = new RegExp("[^\\.]\.[a-zA-Z0-9]{1,4}$");
  function canBeFilename(s) {
    return filenameRegexp.test(s);
  }
  function getBasePath(path) {
    var i = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
    return (i == -1) ? path : path.slice(0, i+1);
  }
  function getLengthInBytes(s) {
    // Non-ASCII chars occupy more than one byte: the compiler
    // breaks after 79 *bytes*, not chars!
    for (var k = 0, len = s.length; k < len; k++) {
      if (s.charCodeAt(k) > 0x7F) len++;
      if (s.charCodeAt(k) > 0x7FF) len++;
      if (s.charCodeAt(k) > 0xFFFF) len++;
    }
    return len;
  }
  const EXISTS = 0;
  const MAYEXIST = 2;
  const DOESNTEXIST = 1;
  const max_print_line = 79;
  // The algorithm works as follows.
  // If the path starts with a quote ("), we are on MiKTeX and the path contains spaces.
  // We just have to read until the next \".
  // Otherwise, we use a double approach: first, we rely on TW.fileExists; second, we
  // check the length of the line. TW.fileExists can return the actual response (EXISTS,
  // DOESNTEXIST) or not (MAYEXIST). Counting the length of the line can be useful to
  // recognize files on multiple lines: a file can continue on the next line only if
  // has been reached the end of the current line.
  // If we know for sure if the file exists, we return an appropriate result.
  // Otherwise we guess if it can be a valid filename, possibly spanning on multiple
  // lines, and remember such candidate when looking ahead for additional chunks.
  return function (output,rootFileName) {
    rootFileName = rootFileName || "";
    var match = fileRegexp.exec(output);
    if (match) {
      output = output.slice(match[0].length);
      if (typeof(match[2]) != "undefined") {
        var basePath = match[2][0] == '.' ? getBasePath(rootFileName) : "";
        var m, svmatch = null, svoutput = null;
        // TODO: we should count preceding characters in the same line, not simply
        // consider max_print_line: filenames may start in the middle of a line.
        // A (real) test case is needed!
        var len = getLengthInBytes(match[0]);
        while (m = fileContinuingRegexp.exec(output)) {
          var sepPos = output.indexOf(m[0]);
          var chunk = output.slice(0, sepPos);
          // trimRight to remove possible spaces before an opening parenthesis
          match[2] += chunk.trimRight();
          len += getLengthInBytes(chunk);
          var existence = TW.fileExists(basePath + match[2]);
          if (m[0] == '(' || m[0] == ')' || existence == EXISTS) {
            output = output.slice(sepPos);
            break;
          }
          if ((m[0] == '/' || m[0] == '\\') && existence == DOESNTEXIST) {
            return null;
          }
          output = output.slice(sepPos + 1);
          if (m[0] != '\n') {
            match[2] += m[0];
            len++;
          }
          else if (len % max_print_line) {
            if (existence == DOESNTEXIST)
              return null;
            if (!canBeFilename(match[2])) {
              if (!svmatch)
                return null;
              match[2] = svmatch;
              output = svoutput;
            }
            break;
          }
          else if (canBeFilename(match[2])) {
            svmatch = match[2];
            svoutput = output;
          }
        }
      }
      else {
        match[1] = match[1].replace(/\n/g, '');
      }
      return { Output: output, File: (match[1] || match[2])};
    }
    return null;
  };
})();


LogParser.prototype.CheckForRerunOfLatex = (function()
{
  var latexmkApplyingRule = new RegExp("^Latexmk: applying rule \'(.*)\'");
  return function(output) {
    if (latexmkApplyingRule.exec(output)) {
      this.Results = [];
    }
  };
})();


LogParser.prototype.WarnAuxFiles = function()
{
  for (var i = 0, len = this.Results.length; i < len; i++) {
    if (this.Results[i].Description.indexOf("File ended while scanning use of") > -1)
      TW.target.removeAuxFiles();
  }
}


LogParser.prototype.GenerateReport = function(onlyTable)
{
  if (this.Results.length > 0) {
    var counters = [ 0, 0, 0 ];
    var sb = new StringBuilder();
    if (this.Settings.SortBy == SortBy.Severity) {
      var reordered = [[], [], []];
      for(var i = 0; i < this.Results.length; i++)  {
        var result = this.Results[i];
        reordered[result.Severity].push(result);
        counters[result.Severity]++;
      }
      for(var i = reordered.length-1; i >= 0; i--) {
        for(var j = 0; j < reordered[i].length; j++)
          sb.append(LogParser.GenerateResultRow(reordered[i][j]));
      }
    }
    else {
      for(var i = 0; i < this.Results.length; i++)  {
        var result = this.Results[i];
        sb.append(LogParser.GenerateResultRow(result));
        counters[result.Severity]++;
      }
    }

    var html = "";
    if (!onlyTable) {
      html += "<html><body>";
      html += "Errors: " + counters[Severity.Error] +
              ", Warnings: " + counters[Severity.Warning] +
              ", Bad boxes: " + counters[Severity.BadBox] + "<hr/>";
    }
    html += "<table border='0' cellspacing='0' cellpadding='4'>";
    html += sb.toString();
    html += "</table>";
    if (!onlyTable) {
      html += "</body></html>";
    }
    return html;
  }
  else {
    return null;
  }
}


LogParser.EscapeHtml = function(str)
{
  var html = str;
  html = html.replace(/&/g, "&amp;");
  html = html.replace(/</g, "&lt;");
  html = html.replace(/>/g, "&gt;");
  html = html.replace(/\n /g, "\n&nbsp;");
  html = html.replace(/  /g, "&nbsp;&nbsp;");
  html = html.replace(/&nbsp; /g, "&nbsp;&nbsp;");
  return html.replace(/\n/g, "<br />\n");
}


LogParser.GenerateResultRow = (function()
{
  var colors = [ "#8080FF", "#F8F800", "#F80000" ];
  var getFilename = new RegExp("([^\\\\/]+)$");
  return function(result) {
    var html = '';
    var color = colors[result.Severity];
    var url = 'texworks:' + result.File + (result.Row != '?' && result.Row != 0 ? '#' + result.Row : '');
    html += '<tr>';
    html += '<td style="background-color: ' + color + '"></td>';
    html += '<td valign="top"><a href="' + url + '">' + getFilename.exec(result.File)[1] + '</a></td>';
    html += '<td valign="top">' + result.Row + '</td>';
    html += '<td valign="top">' + LogParser.EscapeHtml(result.Description) + '</td>';
    html += '</tr>';
    return html;
  };
})();



// We allow other scripts to use and reconfigure this parser
if (typeof(justLoad) == "undefined") {
  var parser = new LogParser();
  parser.Parse(TW.target.consoleOutput, TW.target.rootFileName);
  TW.result = parser.GenerateReport();
}
undefined;
