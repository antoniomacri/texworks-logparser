// TeXworksScript
// Title: Errors, warnings, badboxes
// Description: Looks for errors, warnings or badboxes in the LaTeX terminal output
// Author: Antonio Macr√¨
// Version: 0.7
// Date: 2012-03-08
// Script-Type: hook
// Hook: AfterTypeset

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// String.trim() and String.trimLeft() were introduced in Qt 4.7
if(typeof(String.prototype.trim) == "undefined")
{
  String.prototype.trim = function() { return this.replace(/^[\s\n]+|[\s\n]+$/g, ""); };
}

if(typeof(String.prototype.trimLeft) == "undefined")
{
  String.prototype.trimLeft = function() { return this.replace(/^[\s\n]+/, ""); };
}

// For performance issue, we define and use a StringBuilder
function StringBuilder()
{
  this.buffer = [];
}

StringBuilder.prototype.append = function(s)
{
  this.buffer.push(s);
  return this;
}

StringBuilder.prototype.toString = function()
{
  return this.buffer.join("");
}

// Enums
var Severity = { BadBox:0, Warning:1, Error:2 };
var SortBy = { Severity:0, Occurrence:1 };

// Constructor
function Result(s, f, r, d)
{
  this.Severity = s;
  this.File = f;
  this.Row = r;
  this.Description = d;
}

Result.prototype.Equals = function(that)
{
  return this.Severity == that.Severity && this.File == that.File &&
         this.Row == that.Row && this.Description == that.Description;
}

// Constructor
function LatexOutputParser()
{
  this.Patterns = [
    {
      // This pattern recognizes all errors generated with \errmessage,
      // that is, starting with "!" and containing "l.\d+".
      // The macro \GenericError uses \errmessage internally.
      // Macros \@latex@error and \(Class|Package)Error use \GenericError.
      Regex: new RegExp("^!\\s((?:.*\n)+?l\\.(\\d+)\\s(?:.*\\S.*\n)+)"),
      Callback: function(m, f) {
        return new Result(Severity.Error, f, m[2], m[1].trim());
      }
    },
    {
      // This pattern matches all warnings generated with \(Class|Package)(Warning|WarningNoLine).
      // Additionally, it recognizes other warnings like "LaTeX Font Warning: ...\n(Font) ...".
      // The macro \GenericWarning does not produce formatted output, so it is impossible
      // to match it. We need to look for output generated by higher level commands.
      Regex: new RegExp("^((?:Class|Package|LaTeX) ([^\\s]+) Warning: .+\n)(?:\\(\\2\\)\\s([^\n]+)\n)*(?!\\(\\2\\))"),
      Callback: function(m, f) {
        // We remove "\n(<name>) " from description:
        var desc = m[0].replace(new RegExp("\\(" + m[2] + "\\)\\s([^\n]+)\n", "g"), " $1 ").replace(/\s+/g, " ").trim();
        var row = /on input line (\d+)\./.exec(m[0]);
        return new Result(Severity.Warning, f, row ? row[1] : 0, desc);
      }
    },
    {
      // This pattern matches all warnings generated using \@latex@warning and  \@latex@warning@no@line
      // (which add a little formatting before resorting to \GenericWarning).
      // Warnings generated this way should use \MessageBreak, but sometimes they don't, so we read until we find
      // a dot followed by a newline.
      Regex: new RegExp("^LaTeX Warning: (?:(?!\\.\n).|\n)+\\.\n"),
      Callback: function(m, f) {
        m[0] = m[0].replace(/\n/g, "").trim();
        var row = /on input line (\d+)\./.exec(m[0]);
        return new Result(Severity.Warning, f, row ? row[1] : 0, m[0]);
      }
    },
    {
      // This pattern recognizes badboxes. Each message can span over multiple lines but is terminated by "|".
      Regex: new RegExp("^((?:Under|Over)full \\\\[hv]box\\s*\\([^)]+\\) in paragraph at lines (\\d+)--\\d+)\n.+"),
      Callback: function(m, f) {
        return new Result(Severity.BadBox, f, m[2], m[0].trim());
      }
    }
  ];

  this.Settings = {
    SortBy: SortBy.Occurrence,
    MinimumSeverity: Severity.BadBox
  };
}


LatexOutputParser.prototype.ParseOutput = function(output)
{
  // Generate or clear old results
  this.Results = [];

  var currentFile = undefined;
  var fileStack = [];
  var extraParens = 0;

  while (output.length > 0) {
    // Be sure to remove any whitespace at the beginning of the string
    output = output.trimLeft();

    for (var i =0; i < this.Patterns.length; )
    {
      var match = this.Patterns[i].Regex.exec(output);
      if (match) {
        var result = this.Patterns[i].Callback(match, currentFile);
        if (result) {
          this.Results.push(result);
          // Always trimLeft before looking for a pattern
          output = output.slice(match[0].length).trimLeft();
          i = 0;
        }
      }
      else {
        i++;
      }
    }

    // Go to the first parenthesis or simple skip the first line
    var match = /^[^\n\r()]+/.exec(output);
    if (match) {
      output = output.slice(match[0].length);
    }
    if (output.charAt(0) == ")") {
      if (extraParens > 0) {
        --extraParens;
      }
      else if (fileStack.length > 0) {
        files += padString(indent--*2) + "</" + currentFile + ">\n";
        currentFile = fileStack.pop();
      }
      output = output.slice(1);
    }
    else if (output.charAt(0) == "(") {
      match = new RegExp("^\\(\"((?:\\./|/|.\\\\|[a-zA-Z]:\\\\)(?:[^\"]|\n)+)\"|^\\(((?:\\./|/|.\\\\|[a-zA-Z]:\\\\)(?:(?!\\))[\\S])+)").exec(output);
      if (match) {
        if (typeof(match[2]) != "undefined") {
          // If match[2] is undefined, it was captured a file with spaces,
          // always enclosed in quotes: we don't have to worry.
          var len = match[0].length;
          for (var k=0; k < match[0].length; k++) {
            if (match[0].charCodeAt(k) >= 128) len++;
          }
          output = output.slice(match[0].length);
          // TODO: we should count preceding characters in the same line,
          // not simply consider 79: filenames may start in the middle of a line.
          // Also, non-ASCII chars may occupy more than two bytes: how to distinguish?
          if (output[0] == '\n' && 79 == len) {
            output = output.slice(1); // Removes the '\n'
            // This fails if filename terminates exactly at the end of the line.
            // We retrieve a portion of the next lines (until a space is found).
            var m = /^(?:(?!\))[\S])+/.exec(output);
            if (m) {
              match[2] += m[0];
              output = output.slice(m[0].length);
            }
            // Do we have to check for another line?
            // TODO: Files spanning over two or more lines aren't handled correctly.
          }
        }
        else {
          output = output.slice(match[0].length);
        }
        fileStack.push(currentFile);
        // Filename may contain line breaks inserted by the compiler
        currentFile = (match[1] || match[2]).replace(/\n/g, '');
        files += padString(++indent*2) + "<" + currentFile + ">\n";
        extraParens = 0;
      }
      else {
        ++extraParens;
        output = output.slice(1);
      }
    }
  }
}


LatexOutputParser.prototype.GenerateReport = function(onlyTable)
{
  if (this.Results.length > 0) {
    var counters = [ 0, 0, 0 ];
    var sb = new StringBuilder();
    if (this.Settings.SortBy == SortBy.Severity) {
      var reordered = [[], [], []];
      for(var i = 0; i < this.Results.length; i++)  {
        var result = this.Results[i];
        reordered[result.Severity].push(result);
        counters[result.Severity]++;
      }
      for(var i = reordered.length-1; i >= 0; i--) {
        for(var j = 0; j < reordered[i].length; j++)
          sb.append(LatexOutputParser.GenerateResultRow(reordered[i][j]));
      }
    }
    else {
      for(var i = 0; i < this.Results.length; i++)  {
        var result = this.Results[i];
        sb.append(LatexOutputParser.GenerateResultRow(result));
        counters[result.Severity]++;
      }
    }

    var html = "";
    if (!onlyTable) {
      html += "<html><body>";
      html += "Errors: " + counters[2] +
          ", Warnings: " + counters[1] +
          ", Bad boxes: " + counters[0] + "<hr/>";
    }
    html += "<table border='0' cellspacing='0' cellpadding='4'>";
    html += sb.toString();
    html += "</table>";
    if (!onlyTable) {
      html += "</body></html>";
    }
    return html;
  }
  else {
    return null;
  }
}


function htmlize(str) {
  var html = str;
  html = html.replace(/&(?!amp;|lt;|gt;|nbsp;)/g, "&amp;");
  html = html.replace(/</g, "&lt;");
  html = html.replace(/>/g, "&gt;");
  html = html.replace(/\n /g, "\n&nbsp;");
  html = html.replace(/  /g, "&nbsp;&nbsp;");
  html = html.replace(/&nbsp; /g, "&nbsp;&nbsp;");
  return html.replace(/\n/g, "<br />\n");
}


LatexOutputParser.GenerateResultRow = function(result) {
  var colorsForSeverity = [ "#8080ff", "yellow", "red" ];

  var html = '';
  var url = 'texworks:' + result.File + (result.Row != '?' && result.Row != 0 ? '#' + result.Row : '');
  html += '<tr>';
  html += '<td style="background-color: ' + colorsForSeverity[result.Severity] + '"></td>';
  html += '<td valign="top"><a href="' + url + '">' + /([^\\]+)$/.exec(result.File)[1] + '</a></td>';
  html += '<td valign="top">' + result.Row + '</td>';
  html += '<td valign="top" style="font-family: monospace;">' + htmlize(result.Description) + '</td>';
  html += '</tr>';
  return html;
}


// We allow other scripts to use and reconfigure this parser
if (typeof(justLoad) == "undefined")  {
  var parser = new LatexOutputParser();

  var files = "";
  var indent = 0;

  function padString(length) {
    var str = "";
    while (str.length < length)
      str += " ";
    return str;
  }

  parser.ParseOutput(TW.target.consoleOutput);
  TW.app.clipboard = files;
  TW.result = parser.GenerateReport();
}
undefined;
